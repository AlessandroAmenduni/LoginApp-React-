{"ast":null,"code":"'use strict'; // A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nclass PackJob {\n  constructor(path, absolute) {\n    this.path = path || './';\n    this.absolute = absolute;\n    this.entry = null;\n    this.stat = null;\n    this.readdir = null;\n    this.pending = false;\n    this.ignore = false;\n    this.piped = false;\n  }\n\n}\n\nconst MiniPass = require('minipass');\n\nconst zlib = require('minizlib');\n\nconst ReadEntry = require('./read-entry.js');\n\nconst WriteEntry = require('./write-entry.js');\n\nconst WriteEntrySync = WriteEntry.Sync;\nconst WriteEntryTar = WriteEntry.Tar;\n\nconst Yallist = require('yallist');\n\nconst EOF = Buffer.alloc(1024);\nconst ONSTAT = Symbol('onStat');\nconst ENDED = Symbol('ended');\nconst QUEUE = Symbol('queue');\nconst CURRENT = Symbol('current');\nconst PROCESS = Symbol('process');\nconst PROCESSING = Symbol('processing');\nconst PROCESSJOB = Symbol('processJob');\nconst JOBS = Symbol('jobs');\nconst JOBDONE = Symbol('jobDone');\nconst ADDFSENTRY = Symbol('addFSEntry');\nconst ADDTARENTRY = Symbol('addTarEntry');\nconst STAT = Symbol('stat');\nconst READDIR = Symbol('readdir');\nconst ONREADDIR = Symbol('onreaddir');\nconst PIPE = Symbol('pipe');\nconst ENTRY = Symbol('entry');\nconst ENTRYOPT = Symbol('entryOpt');\nconst WRITEENTRYCLASS = Symbol('writeEntryClass');\nconst WRITE = Symbol('write');\nconst ONDRAIN = Symbol('ondrain');\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst warner = require('./warn-mixin.js');\n\nconst Pack = warner(class Pack extends MiniPass {\n  constructor(opt) {\n    super(opt);\n    opt = opt || Object.create(null);\n    this.opt = opt;\n    this.file = opt.file || '';\n    this.cwd = opt.cwd || process.cwd();\n    this.maxReadSize = opt.maxReadSize;\n    this.preservePaths = !!opt.preservePaths;\n    this.strict = !!opt.strict;\n    this.noPax = !!opt.noPax;\n    this.prefix = (opt.prefix || '').replace(/(\\\\|\\/)+$/, '');\n    this.linkCache = opt.linkCache || new Map();\n    this.statCache = opt.statCache || new Map();\n    this.readdirCache = opt.readdirCache || new Map();\n    this[WRITEENTRYCLASS] = WriteEntry;\n    if (typeof opt.onwarn === 'function') this.on('warn', opt.onwarn);\n    this.portable = !!opt.portable;\n    this.zip = null;\n\n    if (opt.gzip) {\n      if (typeof opt.gzip !== 'object') opt.gzip = {};\n      if (this.portable) opt.gzip.portable = true;\n      this.zip = new zlib.Gzip(opt.gzip);\n      this.zip.on('data', chunk => super.write(chunk));\n      this.zip.on('end', _ => super.end());\n      this.zip.on('drain', _ => this[ONDRAIN]());\n      this.on('resume', _ => this.zip.resume());\n    } else this.on('drain', this[ONDRAIN]);\n\n    this.noDirRecurse = !!opt.noDirRecurse;\n    this.follow = !!opt.follow;\n    this.noMtime = !!opt.noMtime;\n    this.mtime = opt.mtime || null;\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true;\n    this[QUEUE] = new Yallist();\n    this[JOBS] = 0;\n    this.jobs = +opt.jobs || 4;\n    this[PROCESSING] = false;\n    this[ENDED] = false;\n  }\n\n  [WRITE](chunk) {\n    return super.write(chunk);\n  }\n\n  add(path) {\n    this.write(path);\n    return this;\n  }\n\n  end(path) {\n    if (path) this.write(path);\n    this[ENDED] = true;\n    this[PROCESS]();\n    return this;\n  }\n\n  write(path) {\n    if (this[ENDED]) throw new Error('write after end');\n    if (path instanceof ReadEntry) this[ADDTARENTRY](path);else this[ADDFSENTRY](path);\n    return this.flowing;\n  }\n\n  [ADDTARENTRY](p) {\n    const absolute = path.resolve(this.cwd, p.path);\n    if (this.prefix) p.path = this.prefix + '/' + p.path.replace(/^\\.(\\/+|$)/, ''); // in this case, we don't have to wait for the stat\n\n    if (!this.filter(p.path, p)) p.resume();else {\n      const job = new PackJob(p.path, absolute, false);\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));\n      job.entry.on('end', _ => this[JOBDONE](job));\n      this[JOBS] += 1;\n      this[QUEUE].push(job);\n    }\n    this[PROCESS]();\n  }\n\n  [ADDFSENTRY](p) {\n    const absolute = path.resolve(this.cwd, p);\n    if (this.prefix) p = this.prefix + '/' + p.replace(/^\\.(\\/+|$)/, '');\n    this[QUEUE].push(new PackJob(p, absolute));\n    this[PROCESS]();\n  }\n\n  [STAT](job) {\n    job.pending = true;\n    this[JOBS] += 1;\n    const stat = this.follow ? 'stat' : 'lstat';\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false;\n      this[JOBS] -= 1;\n      if (er) this.emit('error', er);else this[ONSTAT](job, stat);\n    });\n  }\n\n  [ONSTAT](job, stat) {\n    this.statCache.set(job.absolute, stat);\n    job.stat = stat; // now we have the stat, we can filter it.\n\n    if (!this.filter(job.path, stat)) job.ignore = true;\n    this[PROCESS]();\n  }\n\n  [READDIR](job) {\n    job.pending = true;\n    this[JOBS] += 1;\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false;\n      this[JOBS] -= 1;\n      if (er) return this.emit('error', er);\n      this[ONREADDIR](job, entries);\n    });\n  }\n\n  [ONREADDIR](job, entries) {\n    this.readdirCache.set(job.absolute, entries);\n    job.readdir = entries;\n    this[PROCESS]();\n  }\n\n  [PROCESS]() {\n    if (this[PROCESSING]) return;\n    this[PROCESSING] = true;\n\n    for (let w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {\n      this[PROCESSJOB](w.value);\n\n      if (w.value.ignore) {\n        const p = w.next;\n        this[QUEUE].removeNode(w);\n        w.next = p;\n      }\n    }\n\n    this[PROCESSING] = false;\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip) this.zip.end(EOF);else {\n        super.write(EOF);\n        super.end();\n      }\n    }\n  }\n\n  get [CURRENT]() {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;\n  }\n\n  [JOBDONE](job) {\n    this[QUEUE].shift();\n    this[JOBS] -= 1;\n    this[PROCESS]();\n  }\n\n  [PROCESSJOB](job) {\n    if (job.pending) return;\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped) this[PIPE](job);\n      return;\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute)) this[ONSTAT](job, this.statCache.get(job.absolute));else this[STAT](job);\n    }\n\n    if (!job.stat) return; // filtered out!\n\n    if (job.ignore) return;\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute)) this[ONREADDIR](job, this.readdirCache.get(job.absolute));else this[READDIR](job);\n      if (!job.readdir) return;\n    } // we know it doesn't have an entry, because that got checked above\n\n\n    job.entry = this[ENTRY](job);\n\n    if (!job.entry) {\n      job.ignore = true;\n      return;\n    }\n\n    if (job === this[CURRENT] && !job.piped) this[PIPE](job);\n  }\n\n  [ENTRYOPT](job) {\n    return {\n      onwarn: (code, msg, data) => this.warn(code, msg, data),\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime\n    };\n  }\n\n  [ENTRY](job) {\n    this[JOBS] += 1;\n\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on('end', () => this[JOBDONE](job)).on('error', er => this.emit('error', er));\n    } catch (er) {\n      this.emit('error', er);\n    }\n  }\n\n  [ONDRAIN]() {\n    if (this[CURRENT] && this[CURRENT].entry) this[CURRENT].entry.resume();\n  } // like .pipe() but using super, because our write() is special\n\n\n  [PIPE](job) {\n    job.piped = true;\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = this.prefix ? job.path.slice(this.prefix.length + 1) || './' : job.path;\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/');\n        this[ADDFSENTRY](base + entry);\n      });\n    }\n\n    const source = job.entry;\n    const zip = this.zip;\n\n    if (zip) {\n      source.on('data', chunk => {\n        if (!zip.write(chunk)) source.pause();\n      });\n    } else {\n      source.on('data', chunk => {\n        if (!super.write(chunk)) source.pause();\n      });\n    }\n  }\n\n  pause() {\n    if (this.zip) this.zip.pause();\n    return super.pause();\n  }\n\n});\n\nclass PackSync extends Pack {\n  constructor(opt) {\n    super(opt);\n    this[WRITEENTRYCLASS] = WriteEntrySync;\n  } // pause/resume are no-ops in sync streams.\n\n\n  pause() {}\n\n  resume() {}\n\n  [STAT](job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync';\n    this[ONSTAT](job, fs[stat](job.absolute));\n  }\n\n  [READDIR](job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute));\n  } // gotta get it all in this tick\n\n\n  [PIPE](job) {\n    const source = job.entry;\n    const zip = this.zip;\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = this.prefix ? job.path.slice(this.prefix.length + 1) || './' : job.path;\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/');\n        this[ADDFSENTRY](base + entry);\n      });\n    }\n\n    if (zip) {\n      source.on('data', chunk => {\n        zip.write(chunk);\n      });\n    } else {\n      source.on('data', chunk => {\n        super[WRITE](chunk);\n      });\n    }\n  }\n\n}\n\nPack.Sync = PackSync;\nmodule.exports = Pack;","map":{"version":3,"sources":["C:/Users/user/Desktop/loginApp/node_modules/tar/lib/pack.js"],"names":["PackJob","constructor","path","absolute","entry","stat","readdir","pending","ignore","piped","MiniPass","require","zlib","ReadEntry","WriteEntry","WriteEntrySync","Sync","WriteEntryTar","Tar","Yallist","EOF","Buffer","alloc","ONSTAT","Symbol","ENDED","QUEUE","CURRENT","PROCESS","PROCESSING","PROCESSJOB","JOBS","JOBDONE","ADDFSENTRY","ADDTARENTRY","STAT","READDIR","ONREADDIR","PIPE","ENTRY","ENTRYOPT","WRITEENTRYCLASS","WRITE","ONDRAIN","fs","warner","Pack","opt","Object","create","file","cwd","process","maxReadSize","preservePaths","strict","noPax","prefix","replace","linkCache","Map","statCache","readdirCache","onwarn","on","portable","zip","gzip","Gzip","chunk","write","_","end","resume","noDirRecurse","follow","noMtime","mtime","filter","jobs","add","Error","flowing","p","resolve","job","push","er","emit","set","entries","w","head","next","value","removeNode","length","shift","has","get","isDirectory","code","msg","data","warn","forEach","slice","base","source","pause","PackSync","readdirSync","module","exports"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\n// A readable tar stream creator\r\n// Technically, this is a transform stream that you write paths into,\r\n// and tar format comes out of.\r\n// The `add()` method is like `write()` but returns this,\r\n// and end() return `this` as well, so you can\r\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\r\n// You could also do something like:\r\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\r\n\r\nclass PackJob {\r\n  constructor (path, absolute) {\r\n    this.path = path || './'\r\n    this.absolute = absolute\r\n    this.entry = null\r\n    this.stat = null\r\n    this.readdir = null\r\n    this.pending = false\r\n    this.ignore = false\r\n    this.piped = false\r\n  }\r\n}\r\n\r\nconst MiniPass = require('minipass')\r\nconst zlib = require('minizlib')\r\nconst ReadEntry = require('./read-entry.js')\r\nconst WriteEntry = require('./write-entry.js')\r\nconst WriteEntrySync = WriteEntry.Sync\r\nconst WriteEntryTar = WriteEntry.Tar\r\nconst Yallist = require('yallist')\r\nconst EOF = Buffer.alloc(1024)\r\nconst ONSTAT = Symbol('onStat')\r\nconst ENDED = Symbol('ended')\r\nconst QUEUE = Symbol('queue')\r\nconst CURRENT = Symbol('current')\r\nconst PROCESS = Symbol('process')\r\nconst PROCESSING = Symbol('processing')\r\nconst PROCESSJOB = Symbol('processJob')\r\nconst JOBS = Symbol('jobs')\r\nconst JOBDONE = Symbol('jobDone')\r\nconst ADDFSENTRY = Symbol('addFSEntry')\r\nconst ADDTARENTRY = Symbol('addTarEntry')\r\nconst STAT = Symbol('stat')\r\nconst READDIR = Symbol('readdir')\r\nconst ONREADDIR = Symbol('onreaddir')\r\nconst PIPE = Symbol('pipe')\r\nconst ENTRY = Symbol('entry')\r\nconst ENTRYOPT = Symbol('entryOpt')\r\nconst WRITEENTRYCLASS = Symbol('writeEntryClass')\r\nconst WRITE = Symbol('write')\r\nconst ONDRAIN = Symbol('ondrain')\r\n\r\nconst fs = require('fs')\r\nconst path = require('path')\r\nconst warner = require('./warn-mixin.js')\r\n\r\nconst Pack = warner(class Pack extends MiniPass {\r\n  constructor (opt) {\r\n    super(opt)\r\n    opt = opt || Object.create(null)\r\n    this.opt = opt\r\n    this.file = opt.file || ''\r\n    this.cwd = opt.cwd || process.cwd()\r\n    this.maxReadSize = opt.maxReadSize\r\n    this.preservePaths = !!opt.preservePaths\r\n    this.strict = !!opt.strict\r\n    this.noPax = !!opt.noPax\r\n    this.prefix = (opt.prefix || '').replace(/(\\\\|\\/)+$/, '')\r\n    this.linkCache = opt.linkCache || new Map()\r\n    this.statCache = opt.statCache || new Map()\r\n    this.readdirCache = opt.readdirCache || new Map()\r\n\r\n    this[WRITEENTRYCLASS] = WriteEntry\r\n    if (typeof opt.onwarn === 'function')\r\n      this.on('warn', opt.onwarn)\r\n\r\n    this.portable = !!opt.portable\r\n    this.zip = null\r\n    if (opt.gzip) {\r\n      if (typeof opt.gzip !== 'object')\r\n        opt.gzip = {}\r\n      if (this.portable)\r\n        opt.gzip.portable = true\r\n      this.zip = new zlib.Gzip(opt.gzip)\r\n      this.zip.on('data', chunk => super.write(chunk))\r\n      this.zip.on('end', _ => super.end())\r\n      this.zip.on('drain', _ => this[ONDRAIN]())\r\n      this.on('resume', _ => this.zip.resume())\r\n    } else\r\n      this.on('drain', this[ONDRAIN])\r\n\r\n    this.noDirRecurse = !!opt.noDirRecurse\r\n    this.follow = !!opt.follow\r\n    this.noMtime = !!opt.noMtime\r\n    this.mtime = opt.mtime || null\r\n\r\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true\r\n\r\n    this[QUEUE] = new Yallist()\r\n    this[JOBS] = 0\r\n    this.jobs = +opt.jobs || 4\r\n    this[PROCESSING] = false\r\n    this[ENDED] = false\r\n  }\r\n\r\n  [WRITE] (chunk) {\r\n    return super.write(chunk)\r\n  }\r\n\r\n  add (path) {\r\n    this.write(path)\r\n    return this\r\n  }\r\n\r\n  end (path) {\r\n    if (path)\r\n      this.write(path)\r\n    this[ENDED] = true\r\n    this[PROCESS]()\r\n    return this\r\n  }\r\n\r\n  write (path) {\r\n    if (this[ENDED])\r\n      throw new Error('write after end')\r\n\r\n    if (path instanceof ReadEntry)\r\n      this[ADDTARENTRY](path)\r\n    else\r\n      this[ADDFSENTRY](path)\r\n    return this.flowing\r\n  }\r\n\r\n  [ADDTARENTRY] (p) {\r\n    const absolute = path.resolve(this.cwd, p.path)\r\n    if (this.prefix)\r\n      p.path = this.prefix + '/' + p.path.replace(/^\\.(\\/+|$)/, '')\r\n\r\n    // in this case, we don't have to wait for the stat\r\n    if (!this.filter(p.path, p))\r\n      p.resume()\r\n    else {\r\n      const job = new PackJob(p.path, absolute, false)\r\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))\r\n      job.entry.on('end', _ => this[JOBDONE](job))\r\n      this[JOBS] += 1\r\n      this[QUEUE].push(job)\r\n    }\r\n\r\n    this[PROCESS]()\r\n  }\r\n\r\n  [ADDFSENTRY] (p) {\r\n    const absolute = path.resolve(this.cwd, p)\r\n    if (this.prefix)\r\n      p = this.prefix + '/' + p.replace(/^\\.(\\/+|$)/, '')\r\n\r\n    this[QUEUE].push(new PackJob(p, absolute))\r\n    this[PROCESS]()\r\n  }\r\n\r\n  [STAT] (job) {\r\n    job.pending = true\r\n    this[JOBS] += 1\r\n    const stat = this.follow ? 'stat' : 'lstat'\r\n    fs[stat](job.absolute, (er, stat) => {\r\n      job.pending = false\r\n      this[JOBS] -= 1\r\n      if (er)\r\n        this.emit('error', er)\r\n      else\r\n        this[ONSTAT](job, stat)\r\n    })\r\n  }\r\n\r\n  [ONSTAT] (job, stat) {\r\n    this.statCache.set(job.absolute, stat)\r\n    job.stat = stat\r\n\r\n    // now we have the stat, we can filter it.\r\n    if (!this.filter(job.path, stat))\r\n      job.ignore = true\r\n\r\n    this[PROCESS]()\r\n  }\r\n\r\n  [READDIR] (job) {\r\n    job.pending = true\r\n    this[JOBS] += 1\r\n    fs.readdir(job.absolute, (er, entries) => {\r\n      job.pending = false\r\n      this[JOBS] -= 1\r\n      if (er)\r\n        return this.emit('error', er)\r\n      this[ONREADDIR](job, entries)\r\n    })\r\n  }\r\n\r\n  [ONREADDIR] (job, entries) {\r\n    this.readdirCache.set(job.absolute, entries)\r\n    job.readdir = entries\r\n    this[PROCESS]()\r\n  }\r\n\r\n  [PROCESS] () {\r\n    if (this[PROCESSING])\r\n      return\r\n\r\n    this[PROCESSING] = true\r\n    for (let w = this[QUEUE].head;\r\n      w !== null && this[JOBS] < this.jobs;\r\n      w = w.next) {\r\n      this[PROCESSJOB](w.value)\r\n      if (w.value.ignore) {\r\n        const p = w.next\r\n        this[QUEUE].removeNode(w)\r\n        w.next = p\r\n      }\r\n    }\r\n\r\n    this[PROCESSING] = false\r\n\r\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\r\n      if (this.zip)\r\n        this.zip.end(EOF)\r\n      else {\r\n        super.write(EOF)\r\n        super.end()\r\n      }\r\n    }\r\n  }\r\n\r\n  get [CURRENT] () {\r\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value\r\n  }\r\n\r\n  [JOBDONE] (job) {\r\n    this[QUEUE].shift()\r\n    this[JOBS] -= 1\r\n    this[PROCESS]()\r\n  }\r\n\r\n  [PROCESSJOB] (job) {\r\n    if (job.pending)\r\n      return\r\n\r\n    if (job.entry) {\r\n      if (job === this[CURRENT] && !job.piped)\r\n        this[PIPE](job)\r\n      return\r\n    }\r\n\r\n    if (!job.stat) {\r\n      if (this.statCache.has(job.absolute))\r\n        this[ONSTAT](job, this.statCache.get(job.absolute))\r\n      else\r\n        this[STAT](job)\r\n    }\r\n    if (!job.stat)\r\n      return\r\n\r\n    // filtered out!\r\n    if (job.ignore)\r\n      return\r\n\r\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\r\n      if (this.readdirCache.has(job.absolute))\r\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute))\r\n      else\r\n        this[READDIR](job)\r\n      if (!job.readdir)\r\n        return\r\n    }\r\n\r\n    // we know it doesn't have an entry, because that got checked above\r\n    job.entry = this[ENTRY](job)\r\n    if (!job.entry) {\r\n      job.ignore = true\r\n      return\r\n    }\r\n\r\n    if (job === this[CURRENT] && !job.piped)\r\n      this[PIPE](job)\r\n  }\r\n\r\n  [ENTRYOPT] (job) {\r\n    return {\r\n      onwarn: (code, msg, data) => this.warn(code, msg, data),\r\n      noPax: this.noPax,\r\n      cwd: this.cwd,\r\n      absolute: job.absolute,\r\n      preservePaths: this.preservePaths,\r\n      maxReadSize: this.maxReadSize,\r\n      strict: this.strict,\r\n      portable: this.portable,\r\n      linkCache: this.linkCache,\r\n      statCache: this.statCache,\r\n      noMtime: this.noMtime,\r\n      mtime: this.mtime,\r\n    }\r\n  }\r\n\r\n  [ENTRY] (job) {\r\n    this[JOBS] += 1\r\n    try {\r\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))\r\n        .on('end', () => this[JOBDONE](job))\r\n        .on('error', er => this.emit('error', er))\r\n    } catch (er) {\r\n      this.emit('error', er)\r\n    }\r\n  }\r\n\r\n  [ONDRAIN] () {\r\n    if (this[CURRENT] && this[CURRENT].entry)\r\n      this[CURRENT].entry.resume()\r\n  }\r\n\r\n  // like .pipe() but using super, because our write() is special\r\n  [PIPE] (job) {\r\n    job.piped = true\r\n\r\n    if (job.readdir) {\r\n      job.readdir.forEach(entry => {\r\n        const p = this.prefix ?\r\n          job.path.slice(this.prefix.length + 1) || './'\r\n          : job.path\r\n\r\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\r\n        this[ADDFSENTRY](base + entry)\r\n      })\r\n    }\r\n\r\n    const source = job.entry\r\n    const zip = this.zip\r\n\r\n    if (zip) {\r\n      source.on('data', chunk => {\r\n        if (!zip.write(chunk))\r\n          source.pause()\r\n      })\r\n    } else {\r\n      source.on('data', chunk => {\r\n        if (!super.write(chunk))\r\n          source.pause()\r\n      })\r\n    }\r\n  }\r\n\r\n  pause () {\r\n    if (this.zip)\r\n      this.zip.pause()\r\n    return super.pause()\r\n  }\r\n})\r\n\r\nclass PackSync extends Pack {\r\n  constructor (opt) {\r\n    super(opt)\r\n    this[WRITEENTRYCLASS] = WriteEntrySync\r\n  }\r\n\r\n  // pause/resume are no-ops in sync streams.\r\n  pause () {}\r\n  resume () {}\r\n\r\n  [STAT] (job) {\r\n    const stat = this.follow ? 'statSync' : 'lstatSync'\r\n    this[ONSTAT](job, fs[stat](job.absolute))\r\n  }\r\n\r\n  [READDIR] (job, stat) {\r\n    this[ONREADDIR](job, fs.readdirSync(job.absolute))\r\n  }\r\n\r\n  // gotta get it all in this tick\r\n  [PIPE] (job) {\r\n    const source = job.entry\r\n    const zip = this.zip\r\n\r\n    if (job.readdir) {\r\n      job.readdir.forEach(entry => {\r\n        const p = this.prefix ?\r\n          job.path.slice(this.prefix.length + 1) || './'\r\n          : job.path\r\n\r\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\r\n        this[ADDFSENTRY](base + entry)\r\n      })\r\n    }\r\n\r\n    if (zip) {\r\n      source.on('data', chunk => {\r\n        zip.write(chunk)\r\n      })\r\n    } else {\r\n      source.on('data', chunk => {\r\n        super[WRITE](chunk)\r\n      })\r\n    }\r\n  }\r\n}\r\n\r\nPack.Sync = PackSync\r\n\r\nmodule.exports = Pack\r\n"]},"metadata":{},"sourceType":"script"}