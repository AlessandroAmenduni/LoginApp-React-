{"ast":null,"code":"'use strict'; // this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\nconst warner = require('./warn-mixin.js');\n\nconst Header = require('./header.js');\n\nconst EE = require('events');\n\nconst Yallist = require('yallist');\n\nconst maxMetaEntrySize = 1024 * 1024;\n\nconst Entry = require('./read-entry.js');\n\nconst Pax = require('./pax.js');\n\nconst zlib = require('minizlib');\n\nconst gzipHeader = Buffer.from([0x1f, 0x8b]);\nconst STATE = Symbol('state');\nconst WRITEENTRY = Symbol('writeEntry');\nconst READENTRY = Symbol('readEntry');\nconst NEXTENTRY = Symbol('nextEntry');\nconst PROCESSENTRY = Symbol('processEntry');\nconst EX = Symbol('extendedHeader');\nconst GEX = Symbol('globalExtendedHeader');\nconst META = Symbol('meta');\nconst EMITMETA = Symbol('emitMeta');\nconst BUFFER = Symbol('buffer');\nconst QUEUE = Symbol('queue');\nconst ENDED = Symbol('ended');\nconst EMITTEDEND = Symbol('emittedEnd');\nconst EMIT = Symbol('emit');\nconst UNZIP = Symbol('unzip');\nconst CONSUMECHUNK = Symbol('consumeChunk');\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub');\nconst CONSUMEBODY = Symbol('consumeBody');\nconst CONSUMEMETA = Symbol('consumeMeta');\nconst CONSUMEHEADER = Symbol('consumeHeader');\nconst CONSUMING = Symbol('consuming');\nconst BUFFERCONCAT = Symbol('bufferConcat');\nconst MAYBEEND = Symbol('maybeEnd');\nconst WRITING = Symbol('writing');\nconst ABORTED = Symbol('aborted');\nconst DONE = Symbol('onDone');\nconst SAW_VALID_ENTRY = Symbol('sawValidEntry');\nconst SAW_NULL_BLOCK = Symbol('sawNullBlock');\nconst SAW_EOF = Symbol('sawEOF');\n\nconst noop = _ => true;\n\nmodule.exports = warner(class Parser extends EE {\n  constructor(opt) {\n    opt = opt || {};\n    super(opt);\n    this.file = opt.file || ''; // set to boolean false when an entry starts.  1024 bytes of \\0\n    // is technically a valid tarball, albeit a boring one.\n\n    this[SAW_VALID_ENTRY] = null; // these BADARCHIVE errors can't be detected early. listen on DONE.\n\n    this.on(DONE, _ => {\n      if (this[STATE] === 'begin' || this[SAW_VALID_ENTRY] === false) {\n        // either less than 1 block of data, or all entries were invalid.\n        // Either way, probably not even a tarball.\n        this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format');\n      }\n    });\n    if (opt.ondone) this.on(DONE, opt.ondone);else {\n      this.on(DONE, _ => {\n        this.emit('prefinish');\n        this.emit('finish');\n        this.emit('end');\n        this.emit('close');\n      });\n    }\n    this.strict = !!opt.strict;\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop; // have to set this so that streams are ok piping into it\n\n    this.writable = true;\n    this.readable = false;\n    this[QUEUE] = new Yallist();\n    this[BUFFER] = null;\n    this[READENTRY] = null;\n    this[WRITEENTRY] = null;\n    this[STATE] = 'begin';\n    this[META] = '';\n    this[EX] = null;\n    this[GEX] = null;\n    this[ENDED] = false;\n    this[UNZIP] = null;\n    this[ABORTED] = false;\n    this[SAW_NULL_BLOCK] = false;\n    this[SAW_EOF] = false;\n    if (typeof opt.onwarn === 'function') this.on('warn', opt.onwarn);\n    if (typeof opt.onentry === 'function') this.on('entry', opt.onentry);\n  }\n\n  [CONSUMEHEADER](chunk, position) {\n    if (this[SAW_VALID_ENTRY] === null) this[SAW_VALID_ENTRY] = false;\n    let header;\n\n    try {\n      header = new Header(chunk, position, this[EX], this[GEX]);\n    } catch (er) {\n      return this.warn('TAR_ENTRY_INVALID', er);\n    }\n\n    if (header.nullBlock) {\n      if (this[SAW_NULL_BLOCK]) {\n        this[SAW_EOF] = true; // ending an archive with no entries.  pointless, but legal.\n\n        if (this[STATE] === 'begin') this[STATE] = 'header';\n        this[EMIT]('eof');\n      } else {\n        this[SAW_NULL_BLOCK] = true;\n        this[EMIT]('nullBlock');\n      }\n    } else {\n      this[SAW_NULL_BLOCK] = false;\n      if (!header.cksumValid) this.warn('TAR_ENTRY_INVALID', 'checksum failure', {\n        header\n      });else if (!header.path) this.warn('TAR_ENTRY_INVALID', 'path is required', {\n        header\n      });else {\n        const type = header.type;\n        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) this.warn('TAR_ENTRY_INVALID', 'linkpath required', {\n          header\n        });else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', {\n          header\n        });else {\n          const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]); // we do this for meta & ignored entries as well, because they\n          // are still valid tar, or else we wouldn't know to ignore them\n\n          if (!this[SAW_VALID_ENTRY]) {\n            if (entry.remain) {\n              // this might be the one!\n              const onend = () => {\n                if (!entry.invalid) this[SAW_VALID_ENTRY] = true;\n              };\n\n              entry.on('end', onend);\n            } else this[SAW_VALID_ENTRY] = true;\n          }\n\n          if (entry.meta) {\n            if (entry.size > this.maxMetaEntrySize) {\n              entry.ignore = true;\n              this[EMIT]('ignoredEntry', entry);\n              this[STATE] = 'ignore';\n              entry.resume();\n            } else if (entry.size > 0) {\n              this[META] = '';\n              entry.on('data', c => this[META] += c);\n              this[STATE] = 'meta';\n            }\n          } else {\n            this[EX] = null;\n            entry.ignore = entry.ignore || !this.filter(entry.path, entry);\n\n            if (entry.ignore) {\n              // probably valid, just not something we care about\n              this[EMIT]('ignoredEntry', entry);\n              this[STATE] = entry.remain ? 'ignore' : 'header';\n              entry.resume();\n            } else {\n              if (entry.remain) this[STATE] = 'body';else {\n                this[STATE] = 'header';\n                entry.end();\n              }\n\n              if (!this[READENTRY]) {\n                this[QUEUE].push(entry);\n                this[NEXTENTRY]();\n              } else this[QUEUE].push(entry);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  [PROCESSENTRY](entry) {\n    let go = true;\n\n    if (!entry) {\n      this[READENTRY] = null;\n      go = false;\n    } else if (Array.isArray(entry)) this.emit.apply(this, entry);else {\n      this[READENTRY] = entry;\n      this.emit('entry', entry);\n\n      if (!entry.emittedEnd) {\n        entry.on('end', _ => this[NEXTENTRY]());\n        go = false;\n      }\n    }\n\n    return go;\n  }\n\n  [NEXTENTRY]() {\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()));\n\n    if (!this[QUEUE].length) {\n      // At this point, there's nothing in the queue, but we may have an\n      // entry which is being consumed (readEntry).\n      // If we don't, then we definitely can handle more data.\n      // If we do, and either it's flowing, or it has never had any data\n      // written to it, then it needs more.\n      // The only other possibility is that it has returned false from a\n      // write() call, so we wait for the next drain to continue.\n      const re = this[READENTRY];\n      const drainNow = !re || re.flowing || re.size === re.remain;\n\n      if (drainNow) {\n        if (!this[WRITING]) this.emit('drain');\n      } else re.once('drain', _ => this.emit('drain'));\n    }\n  }\n\n  [CONSUMEBODY](chunk, position) {\n    // write up to but no  more than writeEntry.blockRemain\n    const entry = this[WRITEENTRY];\n    const br = entry.blockRemain;\n    const c = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);\n    entry.write(c);\n\n    if (!entry.blockRemain) {\n      this[STATE] = 'header';\n      this[WRITEENTRY] = null;\n      entry.end();\n    }\n\n    return c.length;\n  }\n\n  [CONSUMEMETA](chunk, position) {\n    const entry = this[WRITEENTRY];\n    const ret = this[CONSUMEBODY](chunk, position); // if we finished, then the entry is reset\n\n    if (!this[WRITEENTRY]) this[EMITMETA](entry);\n    return ret;\n  }\n\n  [EMIT](ev, data, extra) {\n    if (!this[QUEUE].length && !this[READENTRY]) this.emit(ev, data, extra);else this[QUEUE].push([ev, data, extra]);\n  }\n\n  [EMITMETA](entry) {\n    this[EMIT]('meta', this[META]);\n\n    switch (entry.type) {\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this[EX] = Pax.parse(this[META], this[EX], false);\n        break;\n\n      case 'GlobalExtendedHeader':\n        this[GEX] = Pax.parse(this[META], this[GEX], true);\n        break;\n\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n        this[EX] = this[EX] || Object.create(null);\n        this[EX].path = this[META].replace(/\\0.*/, '');\n        break;\n\n      case 'NextFileHasLongLinkpath':\n        this[EX] = this[EX] || Object.create(null);\n        this[EX].linkpath = this[META].replace(/\\0.*/, '');\n        break;\n\n      /* istanbul ignore next */\n\n      default:\n        throw new Error('unknown meta: ' + entry.type);\n    }\n  }\n\n  abort(error) {\n    this[ABORTED] = true;\n    this.emit('abort', error); // always throws, even in non-strict mode\n\n    this.warn('TAR_ABORT', error, {\n      recoverable: false\n    });\n  }\n\n  write(chunk) {\n    if (this[ABORTED]) return; // first write, might be gzipped\n\n    if (this[UNZIP] === null && chunk) {\n      if (this[BUFFER]) {\n        chunk = Buffer.concat([this[BUFFER], chunk]);\n        this[BUFFER] = null;\n      }\n\n      if (chunk.length < gzipHeader.length) {\n        this[BUFFER] = chunk;\n        return true;\n      }\n\n      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\n        if (chunk[i] !== gzipHeader[i]) this[UNZIP] = false;\n      }\n\n      if (this[UNZIP] === null) {\n        const ended = this[ENDED];\n        this[ENDED] = false;\n        this[UNZIP] = new zlib.Unzip();\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk));\n        this[UNZIP].on('error', er => this.abort(er));\n        this[UNZIP].on('end', _ => {\n          this[ENDED] = true;\n          this[CONSUMECHUNK]();\n        });\n        this[WRITING] = true;\n        const ret = this[UNZIP][ended ? 'end' : 'write'](chunk);\n        this[WRITING] = false;\n        return ret;\n      }\n    }\n\n    this[WRITING] = true;\n    if (this[UNZIP]) this[UNZIP].write(chunk);else this[CONSUMECHUNK](chunk);\n    this[WRITING] = false; // return false if there's a queue, or if the current entry isn't flowing\n\n    const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true; // if we have no queue, then that means a clogged READENTRY\n\n    if (!ret && !this[QUEUE].length) this[READENTRY].once('drain', _ => this.emit('drain'));\n    return ret;\n  }\n\n  [BUFFERCONCAT](c) {\n    if (c && !this[ABORTED]) this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;\n  }\n\n  [MAYBEEND]() {\n    if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {\n      this[EMITTEDEND] = true;\n      const entry = this[WRITEENTRY];\n\n      if (entry && entry.blockRemain) {\n        // truncated, likely a damaged file\n        const have = this[BUFFER] ? this[BUFFER].length : 0;\n        this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, {\n          entry\n        });\n        if (this[BUFFER]) entry.write(this[BUFFER]);\n        entry.end();\n      }\n\n      this[EMIT](DONE);\n    }\n  }\n\n  [CONSUMECHUNK](chunk) {\n    if (this[CONSUMING]) this[BUFFERCONCAT](chunk);else if (!chunk && !this[BUFFER]) this[MAYBEEND]();else {\n      this[CONSUMING] = true;\n\n      if (this[BUFFER]) {\n        this[BUFFERCONCAT](chunk);\n        const c = this[BUFFER];\n        this[BUFFER] = null;\n        this[CONSUMECHUNKSUB](c);\n      } else this[CONSUMECHUNKSUB](chunk);\n\n      while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {\n        const c = this[BUFFER];\n        this[BUFFER] = null;\n        this[CONSUMECHUNKSUB](c);\n      }\n\n      this[CONSUMING] = false;\n    }\n    if (!this[BUFFER] || this[ENDED]) this[MAYBEEND]();\n  }\n\n  [CONSUMECHUNKSUB](chunk) {\n    // we know that we are in CONSUMING mode, so anything written goes into\n    // the buffer.  Advance the position and put any remainder in the buffer.\n    let position = 0;\n    const length = chunk.length;\n\n    while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {\n      switch (this[STATE]) {\n        case 'begin':\n        case 'header':\n          this[CONSUMEHEADER](chunk, position);\n          position += 512;\n          break;\n\n        case 'ignore':\n        case 'body':\n          position += this[CONSUMEBODY](chunk, position);\n          break;\n\n        case 'meta':\n          position += this[CONSUMEMETA](chunk, position);\n          break;\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error('invalid state: ' + this[STATE]);\n      }\n    }\n\n    if (position < length) {\n      if (this[BUFFER]) this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);else this[BUFFER] = chunk.slice(position);\n    }\n  }\n\n  end(chunk) {\n    if (!this[ABORTED]) {\n      if (this[UNZIP]) this[UNZIP].end(chunk);else {\n        this[ENDED] = true;\n        this.write(chunk);\n      }\n    }\n  }\n\n});","map":{"version":3,"sources":["C:/Users/user/Desktop/loginApp/node_modules/tar/lib/parse.js"],"names":["warner","require","Header","EE","Yallist","maxMetaEntrySize","Entry","Pax","zlib","gzipHeader","Buffer","from","STATE","Symbol","WRITEENTRY","READENTRY","NEXTENTRY","PROCESSENTRY","EX","GEX","META","EMITMETA","BUFFER","QUEUE","ENDED","EMITTEDEND","EMIT","UNZIP","CONSUMECHUNK","CONSUMECHUNKSUB","CONSUMEBODY","CONSUMEMETA","CONSUMEHEADER","CONSUMING","BUFFERCONCAT","MAYBEEND","WRITING","ABORTED","DONE","SAW_VALID_ENTRY","SAW_NULL_BLOCK","SAW_EOF","noop","_","module","exports","Parser","constructor","opt","file","on","warn","ondone","emit","strict","filter","writable","readable","onwarn","onentry","chunk","position","header","er","nullBlock","cksumValid","path","type","test","linkpath","entry","remain","onend","invalid","meta","size","ignore","resume","c","end","push","go","Array","isArray","apply","emittedEnd","shift","length","re","drainNow","flowing","once","br","blockRemain","slice","write","ret","ev","data","extra","parse","Object","create","replace","Error","abort","error","recoverable","concat","i","ended","Unzip","have"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\n// this[BUFFER] is the remainder of a chunk if we're waiting for\r\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\r\n// it to the next write(), which is a mem copy, but a small one.\r\n//\r\n// this[QUEUE] is a Yallist of entries that haven't been emitted\r\n// yet this can only get filled up if the user keeps write()ing after\r\n// a write() returns false, or does a write() with more than one entry\r\n//\r\n// We don't buffer chunks, we always parse them and either create an\r\n// entry, or push it into the active entry.  The ReadEntry class knows\r\n// to throw data away if .ignore=true\r\n//\r\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\r\n// the next one in the list.\r\n//\r\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\r\n// and waiting for 'end' on the entry at READENTRY\r\n//\r\n// ignored entries get .resume() called on them straight away\r\n\r\nconst warner = require('./warn-mixin.js')\r\nconst Header = require('./header.js')\r\nconst EE = require('events')\r\nconst Yallist = require('yallist')\r\nconst maxMetaEntrySize = 1024 * 1024\r\nconst Entry = require('./read-entry.js')\r\nconst Pax = require('./pax.js')\r\nconst zlib = require('minizlib')\r\n\r\nconst gzipHeader = Buffer.from([0x1f, 0x8b])\r\nconst STATE = Symbol('state')\r\nconst WRITEENTRY = Symbol('writeEntry')\r\nconst READENTRY = Symbol('readEntry')\r\nconst NEXTENTRY = Symbol('nextEntry')\r\nconst PROCESSENTRY = Symbol('processEntry')\r\nconst EX = Symbol('extendedHeader')\r\nconst GEX = Symbol('globalExtendedHeader')\r\nconst META = Symbol('meta')\r\nconst EMITMETA = Symbol('emitMeta')\r\nconst BUFFER = Symbol('buffer')\r\nconst QUEUE = Symbol('queue')\r\nconst ENDED = Symbol('ended')\r\nconst EMITTEDEND = Symbol('emittedEnd')\r\nconst EMIT = Symbol('emit')\r\nconst UNZIP = Symbol('unzip')\r\nconst CONSUMECHUNK = Symbol('consumeChunk')\r\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub')\r\nconst CONSUMEBODY = Symbol('consumeBody')\r\nconst CONSUMEMETA = Symbol('consumeMeta')\r\nconst CONSUMEHEADER = Symbol('consumeHeader')\r\nconst CONSUMING = Symbol('consuming')\r\nconst BUFFERCONCAT = Symbol('bufferConcat')\r\nconst MAYBEEND = Symbol('maybeEnd')\r\nconst WRITING = Symbol('writing')\r\nconst ABORTED = Symbol('aborted')\r\nconst DONE = Symbol('onDone')\r\nconst SAW_VALID_ENTRY = Symbol('sawValidEntry')\r\nconst SAW_NULL_BLOCK = Symbol('sawNullBlock')\r\nconst SAW_EOF = Symbol('sawEOF')\r\n\r\nconst noop = _ => true\r\n\r\nmodule.exports = warner(class Parser extends EE {\r\n  constructor (opt) {\r\n    opt = opt || {}\r\n    super(opt)\r\n\r\n    this.file = opt.file || ''\r\n\r\n    // set to boolean false when an entry starts.  1024 bytes of \\0\r\n    // is technically a valid tarball, albeit a boring one.\r\n    this[SAW_VALID_ENTRY] = null\r\n\r\n    // these BADARCHIVE errors can't be detected early. listen on DONE.\r\n    this.on(DONE, _ => {\r\n      if (this[STATE] === 'begin' || this[SAW_VALID_ENTRY] === false) {\r\n        // either less than 1 block of data, or all entries were invalid.\r\n        // Either way, probably not even a tarball.\r\n        this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format')\r\n      }\r\n    })\r\n\r\n    if (opt.ondone)\r\n      this.on(DONE, opt.ondone)\r\n    else {\r\n      this.on(DONE, _ => {\r\n        this.emit('prefinish')\r\n        this.emit('finish')\r\n        this.emit('end')\r\n        this.emit('close')\r\n      })\r\n    }\r\n\r\n    this.strict = !!opt.strict\r\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize\r\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop\r\n\r\n    // have to set this so that streams are ok piping into it\r\n    this.writable = true\r\n    this.readable = false\r\n\r\n    this[QUEUE] = new Yallist()\r\n    this[BUFFER] = null\r\n    this[READENTRY] = null\r\n    this[WRITEENTRY] = null\r\n    this[STATE] = 'begin'\r\n    this[META] = ''\r\n    this[EX] = null\r\n    this[GEX] = null\r\n    this[ENDED] = false\r\n    this[UNZIP] = null\r\n    this[ABORTED] = false\r\n    this[SAW_NULL_BLOCK] = false\r\n    this[SAW_EOF] = false\r\n    if (typeof opt.onwarn === 'function')\r\n      this.on('warn', opt.onwarn)\r\n    if (typeof opt.onentry === 'function')\r\n      this.on('entry', opt.onentry)\r\n  }\r\n\r\n  [CONSUMEHEADER] (chunk, position) {\r\n    if (this[SAW_VALID_ENTRY] === null)\r\n      this[SAW_VALID_ENTRY] = false\r\n    let header\r\n    try {\r\n      header = new Header(chunk, position, this[EX], this[GEX])\r\n    } catch (er) {\r\n      return this.warn('TAR_ENTRY_INVALID', er)\r\n    }\r\n\r\n    if (header.nullBlock) {\r\n      if (this[SAW_NULL_BLOCK]) {\r\n        this[SAW_EOF] = true\r\n        // ending an archive with no entries.  pointless, but legal.\r\n        if (this[STATE] === 'begin')\r\n          this[STATE] = 'header'\r\n        this[EMIT]('eof')\r\n      } else {\r\n        this[SAW_NULL_BLOCK] = true\r\n        this[EMIT]('nullBlock')\r\n      }\r\n    } else {\r\n      this[SAW_NULL_BLOCK] = false\r\n      if (!header.cksumValid)\r\n        this.warn('TAR_ENTRY_INVALID', 'checksum failure', {header})\r\n      else if (!header.path)\r\n        this.warn('TAR_ENTRY_INVALID', 'path is required', {header})\r\n      else {\r\n        const type = header.type\r\n        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)\r\n          this.warn('TAR_ENTRY_INVALID', 'linkpath required', {header})\r\n        else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)\r\n          this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', {header})\r\n        else {\r\n          const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])\r\n\r\n          // we do this for meta & ignored entries as well, because they\r\n          // are still valid tar, or else we wouldn't know to ignore them\r\n          if (!this[SAW_VALID_ENTRY]) {\r\n            if (entry.remain) {\r\n              // this might be the one!\r\n              const onend = () => {\r\n                if (!entry.invalid)\r\n                  this[SAW_VALID_ENTRY] = true\r\n              }\r\n              entry.on('end', onend)\r\n            } else\r\n              this[SAW_VALID_ENTRY] = true\r\n          }\r\n\r\n          if (entry.meta) {\r\n            if (entry.size > this.maxMetaEntrySize) {\r\n              entry.ignore = true\r\n              this[EMIT]('ignoredEntry', entry)\r\n              this[STATE] = 'ignore'\r\n              entry.resume()\r\n            } else if (entry.size > 0) {\r\n              this[META] = ''\r\n              entry.on('data', c => this[META] += c)\r\n              this[STATE] = 'meta'\r\n            }\r\n          } else {\r\n            this[EX] = null\r\n            entry.ignore = entry.ignore || !this.filter(entry.path, entry)\r\n\r\n            if (entry.ignore) {\r\n              // probably valid, just not something we care about\r\n              this[EMIT]('ignoredEntry', entry)\r\n              this[STATE] = entry.remain ? 'ignore' : 'header'\r\n              entry.resume()\r\n            } else {\r\n              if (entry.remain)\r\n                this[STATE] = 'body'\r\n              else {\r\n                this[STATE] = 'header'\r\n                entry.end()\r\n              }\r\n\r\n              if (!this[READENTRY]) {\r\n                this[QUEUE].push(entry)\r\n                this[NEXTENTRY]()\r\n              } else\r\n                this[QUEUE].push(entry)\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  [PROCESSENTRY] (entry) {\r\n    let go = true\r\n\r\n    if (!entry) {\r\n      this[READENTRY] = null\r\n      go = false\r\n    } else if (Array.isArray(entry))\r\n      this.emit.apply(this, entry)\r\n    else {\r\n      this[READENTRY] = entry\r\n      this.emit('entry', entry)\r\n      if (!entry.emittedEnd) {\r\n        entry.on('end', _ => this[NEXTENTRY]())\r\n        go = false\r\n      }\r\n    }\r\n\r\n    return go\r\n  }\r\n\r\n  [NEXTENTRY] () {\r\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))\r\n\r\n    if (!this[QUEUE].length) {\r\n      // At this point, there's nothing in the queue, but we may have an\r\n      // entry which is being consumed (readEntry).\r\n      // If we don't, then we definitely can handle more data.\r\n      // If we do, and either it's flowing, or it has never had any data\r\n      // written to it, then it needs more.\r\n      // The only other possibility is that it has returned false from a\r\n      // write() call, so we wait for the next drain to continue.\r\n      const re = this[READENTRY]\r\n      const drainNow = !re || re.flowing || re.size === re.remain\r\n      if (drainNow) {\r\n        if (!this[WRITING])\r\n          this.emit('drain')\r\n      } else\r\n        re.once('drain', _ => this.emit('drain'))\r\n    }\r\n  }\r\n\r\n  [CONSUMEBODY] (chunk, position) {\r\n    // write up to but no  more than writeEntry.blockRemain\r\n    const entry = this[WRITEENTRY]\r\n    const br = entry.blockRemain\r\n    const c = (br >= chunk.length && position === 0) ? chunk\r\n      : chunk.slice(position, position + br)\r\n\r\n    entry.write(c)\r\n\r\n    if (!entry.blockRemain) {\r\n      this[STATE] = 'header'\r\n      this[WRITEENTRY] = null\r\n      entry.end()\r\n    }\r\n\r\n    return c.length\r\n  }\r\n\r\n  [CONSUMEMETA] (chunk, position) {\r\n    const entry = this[WRITEENTRY]\r\n    const ret = this[CONSUMEBODY](chunk, position)\r\n\r\n    // if we finished, then the entry is reset\r\n    if (!this[WRITEENTRY])\r\n      this[EMITMETA](entry)\r\n\r\n    return ret\r\n  }\r\n\r\n  [EMIT] (ev, data, extra) {\r\n    if (!this[QUEUE].length && !this[READENTRY])\r\n      this.emit(ev, data, extra)\r\n    else\r\n      this[QUEUE].push([ev, data, extra])\r\n  }\r\n\r\n  [EMITMETA] (entry) {\r\n    this[EMIT]('meta', this[META])\r\n    switch (entry.type) {\r\n      case 'ExtendedHeader':\r\n      case 'OldExtendedHeader':\r\n        this[EX] = Pax.parse(this[META], this[EX], false)\r\n        break\r\n\r\n      case 'GlobalExtendedHeader':\r\n        this[GEX] = Pax.parse(this[META], this[GEX], true)\r\n        break\r\n\r\n      case 'NextFileHasLongPath':\r\n      case 'OldGnuLongPath':\r\n        this[EX] = this[EX] || Object.create(null)\r\n        this[EX].path = this[META].replace(/\\0.*/, '')\r\n        break\r\n\r\n      case 'NextFileHasLongLinkpath':\r\n        this[EX] = this[EX] || Object.create(null)\r\n        this[EX].linkpath = this[META].replace(/\\0.*/, '')\r\n        break\r\n\r\n      /* istanbul ignore next */\r\n      default: throw new Error('unknown meta: ' + entry.type)\r\n    }\r\n  }\r\n\r\n  abort (error) {\r\n    this[ABORTED] = true\r\n    this.emit('abort', error)\r\n    // always throws, even in non-strict mode\r\n    this.warn('TAR_ABORT', error, { recoverable: false })\r\n  }\r\n\r\n  write (chunk) {\r\n    if (this[ABORTED])\r\n      return\r\n\r\n    // first write, might be gzipped\r\n    if (this[UNZIP] === null && chunk) {\r\n      if (this[BUFFER]) {\r\n        chunk = Buffer.concat([this[BUFFER], chunk])\r\n        this[BUFFER] = null\r\n      }\r\n      if (chunk.length < gzipHeader.length) {\r\n        this[BUFFER] = chunk\r\n        return true\r\n      }\r\n      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\r\n        if (chunk[i] !== gzipHeader[i])\r\n          this[UNZIP] = false\r\n      }\r\n      if (this[UNZIP] === null) {\r\n        const ended = this[ENDED]\r\n        this[ENDED] = false\r\n        this[UNZIP] = new zlib.Unzip()\r\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))\r\n        this[UNZIP].on('error', er => this.abort(er))\r\n        this[UNZIP].on('end', _ => {\r\n          this[ENDED] = true\r\n          this[CONSUMECHUNK]()\r\n        })\r\n        this[WRITING] = true\r\n        const ret = this[UNZIP][ended ? 'end' : 'write'](chunk)\r\n        this[WRITING] = false\r\n        return ret\r\n      }\r\n    }\r\n\r\n    this[WRITING] = true\r\n    if (this[UNZIP])\r\n      this[UNZIP].write(chunk)\r\n    else\r\n      this[CONSUMECHUNK](chunk)\r\n    this[WRITING] = false\r\n\r\n    // return false if there's a queue, or if the current entry isn't flowing\r\n    const ret =\r\n      this[QUEUE].length ? false :\r\n      this[READENTRY] ? this[READENTRY].flowing :\r\n      true\r\n\r\n    // if we have no queue, then that means a clogged READENTRY\r\n    if (!ret && !this[QUEUE].length)\r\n      this[READENTRY].once('drain', _ => this.emit('drain'))\r\n\r\n    return ret\r\n  }\r\n\r\n  [BUFFERCONCAT] (c) {\r\n    if (c && !this[ABORTED])\r\n      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c\r\n  }\r\n\r\n  [MAYBEEND] () {\r\n    if (this[ENDED] &&\r\n        !this[EMITTEDEND] &&\r\n        !this[ABORTED] &&\r\n        !this[CONSUMING]) {\r\n      this[EMITTEDEND] = true\r\n      const entry = this[WRITEENTRY]\r\n      if (entry && entry.blockRemain) {\r\n        // truncated, likely a damaged file\r\n        const have = this[BUFFER] ? this[BUFFER].length : 0\r\n        this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${\r\n          entry.blockRemain} more bytes, only ${have} available)`, {entry})\r\n        if (this[BUFFER])\r\n          entry.write(this[BUFFER])\r\n        entry.end()\r\n      }\r\n      this[EMIT](DONE)\r\n    }\r\n  }\r\n\r\n  [CONSUMECHUNK] (chunk) {\r\n    if (this[CONSUMING])\r\n      this[BUFFERCONCAT](chunk)\r\n    else if (!chunk && !this[BUFFER])\r\n      this[MAYBEEND]()\r\n    else {\r\n      this[CONSUMING] = true\r\n      if (this[BUFFER]) {\r\n        this[BUFFERCONCAT](chunk)\r\n        const c = this[BUFFER]\r\n        this[BUFFER] = null\r\n        this[CONSUMECHUNKSUB](c)\r\n      } else\r\n        this[CONSUMECHUNKSUB](chunk)\r\n\r\n      while (this[BUFFER] &&\r\n          this[BUFFER].length >= 512 &&\r\n          !this[ABORTED] &&\r\n          !this[SAW_EOF]) {\r\n        const c = this[BUFFER]\r\n        this[BUFFER] = null\r\n        this[CONSUMECHUNKSUB](c)\r\n      }\r\n      this[CONSUMING] = false\r\n    }\r\n\r\n    if (!this[BUFFER] || this[ENDED])\r\n      this[MAYBEEND]()\r\n  }\r\n\r\n  [CONSUMECHUNKSUB] (chunk) {\r\n    // we know that we are in CONSUMING mode, so anything written goes into\r\n    // the buffer.  Advance the position and put any remainder in the buffer.\r\n    let position = 0\r\n    const length = chunk.length\r\n    while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {\r\n      switch (this[STATE]) {\r\n        case 'begin':\r\n        case 'header':\r\n          this[CONSUMEHEADER](chunk, position)\r\n          position += 512\r\n          break\r\n\r\n        case 'ignore':\r\n        case 'body':\r\n          position += this[CONSUMEBODY](chunk, position)\r\n          break\r\n\r\n        case 'meta':\r\n          position += this[CONSUMEMETA](chunk, position)\r\n          break\r\n\r\n        /* istanbul ignore next */\r\n        default:\r\n          throw new Error('invalid state: ' + this[STATE])\r\n      }\r\n    }\r\n\r\n    if (position < length) {\r\n      if (this[BUFFER])\r\n        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])\r\n      else\r\n        this[BUFFER] = chunk.slice(position)\r\n    }\r\n  }\r\n\r\n  end (chunk) {\r\n    if (!this[ABORTED]) {\r\n      if (this[UNZIP])\r\n        this[UNZIP].end(chunk)\r\n      else {\r\n        this[ENDED] = true\r\n        this.write(chunk)\r\n      }\r\n    }\r\n  }\r\n})\r\n"]},"metadata":{},"sourceType":"script"}